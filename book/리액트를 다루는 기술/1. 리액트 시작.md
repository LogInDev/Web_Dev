# 목차
- [목차](#목차)
- [리액트 시작](#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8B%9C%EC%9E%91)
  - [왜 리액트인가](#%EC%99%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%B8%EA%B0%80)
  
 
 
# 리액트 시작
## 왜 리액트인가
### 초기 렌더링
- 맨 처음 어떻게 보일지를 정하는 것
- 리액트에서는 `render`함수를 통해 다룸
  - 
    
    ```jsx
    render() {...}
    ```
    
    - 컴포넌트가 어떻게 생겼는지 정의
    - 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환
    - 컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈 수 있음 → render함수를 실행하면 내부에 있는 컴포넌트들도 재귀적으로 렌더링 됨
    - html 마크업(markup)을 만들고, 이를 우리가 정하는 실제 페이지의 DOM 요소 안에 주입
    
    ![](asset/리액트를 다루는 기술/re1-1.png)
    
    
- 컴포넌트를 실제 페이지에 렌더링할 때 절차
  1. 문자열 형태의 HTML 코드를 생성함.
  2. 특정 DOM에 해당 내용을 주입하면 이벤트 적용

### 조화 과정
- 리액트에서 뷰를 업데이트 할 때는 “업데이트 고정을 거친다”라고 하기보다는 “조화 과정(reconciliation)을 거친다”라고 함. → 변화에 따라 뷰가 변형되는 것이 아닌 새로운 요소로 갈아 끼우는 것
![](asset/리액트를 다루는 기술/re1-2.png)
- render함수를 통해 시행함 → render함수는 뷰가 어떻게 생겼고 어떻게 작동하는지 객체를 반환 → 컴포넌트 업데이트 시 단순 업데이트 값 수정이 아닌 새로운 데이터를 가지고 render함수를 또 다시 호출 → 그 데이터를 지닌 뷰를 생성
- 이때 render함수가 반환하는 결과를 곧바로 DOM에 반영하지 않고, 이전에 render함수가 만들었던 컴포넌트 정보와 현재 render함수가 만든 컴포넌트 정보를 비교 
- 자바스크립트를 사용하여 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트ㅇ
![](asset/리액트를 다루는 기술/re1-3.png)
